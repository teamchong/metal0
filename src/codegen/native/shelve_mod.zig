/// Python shelve module - Python object persistence
const std = @import("std");
const ast = @import("ast");
const CodegenError = @import("main.zig").CodegenError;
const NativeCodegen = @import("main.zig").NativeCodegen;

const ModuleHandler = *const fn (*NativeCodegen, []ast.Node) CodegenError!void;
fn genConst(comptime v: []const u8) ModuleHandler {
    return struct { fn f(self: *NativeCodegen, args: []ast.Node) CodegenError!void { _ = args; try self.emit(v); } }.f;
}

pub const Funcs = std.StaticStringMap(ModuleHandler).initComptime(.{
    .{ "open", genConst("struct { filename: []const u8 = \"\", data: hashmap_helper.StringHashMap([]const u8) = .{}, writeback: bool = false, pub fn get(__self: *@This(), key: []const u8) ?[]const u8 { return __self.data.get(key); } pub fn put(__self: *@This(), key: []const u8, value: []const u8) void { __self.data.put(__self.data.allocator, key, value) catch {}; } pub fn delete(__self: *@This(), key: []const u8) void { _ = __self.data.remove(key); } pub fn keys(__self: *@This()) [][]const u8 { _ = __self; return &[_][]const u8{}; } pub fn values(__self: *@This()) [][]const u8 { _ = __self; return &[_][]const u8{}; } pub fn items(__self: *@This()) []struct { key: []const u8, value: []const u8 } { _ = __self; return &.{}; } pub fn __len__(__self: *@This()) usize { return __self.data.count(); } pub fn __contains__(__self: *@This(), key: []const u8) bool { return __self.data.get(key) != null; } pub fn sync(__self: *@This()) void { _ = __self; } pub fn close(__self: *@This()) void { _ = __self; } pub fn __enter__(__self: *@This()) *@This() { return __self; } pub fn __exit__(__self: *@This(), _: anytype) void { __self.close(); } }{}") },
    .{ "Shelf", genConst("struct { filename: []const u8 = \"\", data: hashmap_helper.StringHashMap([]const u8) = .{}, writeback: bool = false, pub fn get(__self: *@This(), key: []const u8) ?[]const u8 { return __self.data.get(key); } pub fn put(__self: *@This(), key: []const u8, value: []const u8) void { __self.data.put(__self.data.allocator, key, value) catch {}; } pub fn delete(__self: *@This(), key: []const u8) void { _ = __self.data.remove(key); } pub fn keys(__self: *@This()) [][]const u8 { _ = __self; return &[_][]const u8{}; } pub fn values(__self: *@This()) [][]const u8 { _ = __self; return &[_][]const u8{}; } pub fn items(__self: *@This()) []struct { key: []const u8, value: []const u8 } { _ = __self; return &.{}; } pub fn __len__(__self: *@This()) usize { return __self.data.count(); } pub fn __contains__(__self: *@This(), key: []const u8) bool { return __self.data.get(key) != null; } pub fn sync(__self: *@This()) void { _ = __self; } pub fn close(__self: *@This()) void { _ = __self; } pub fn __enter__(__self: *@This()) *@This() { return __self; } pub fn __exit__(__self: *@This(), _: anytype) void { __self.close(); } }{}") },
    .{ "BsdDbShelf", genConst("struct { filename: []const u8 = \"\", data: hashmap_helper.StringHashMap([]const u8) = .{}, writeback: bool = false, pub fn get(__self: *@This(), key: []const u8) ?[]const u8 { return __self.data.get(key); } pub fn put(__self: *@This(), key: []const u8, value: []const u8) void { __self.data.put(__self.data.allocator, key, value) catch {}; } pub fn delete(__self: *@This(), key: []const u8) void { _ = __self.data.remove(key); } pub fn keys(__self: *@This()) [][]const u8 { _ = __self; return &[_][]const u8{}; } pub fn values(__self: *@This()) [][]const u8 { _ = __self; return &[_][]const u8{}; } pub fn items(__self: *@This()) []struct { key: []const u8, value: []const u8 } { _ = __self; return &.{}; } pub fn __len__(__self: *@This()) usize { return __self.data.count(); } pub fn __contains__(__self: *@This(), key: []const u8) bool { return __self.data.get(key) != null; } pub fn sync(__self: *@This()) void { _ = __self; } pub fn close(__self: *@This()) void { _ = __self; } pub fn __enter__(__self: *@This()) *@This() { return __self; } pub fn __exit__(__self: *@This(), _: anytype) void { __self.close(); } }{}") },
    .{ "DbfilenameShelf", genConst("struct { filename: []const u8 = \"\", data: hashmap_helper.StringHashMap([]const u8) = .{}, writeback: bool = false, pub fn get(__self: *@This(), key: []const u8) ?[]const u8 { return __self.data.get(key); } pub fn put(__self: *@This(), key: []const u8, value: []const u8) void { __self.data.put(__self.data.allocator, key, value) catch {}; } pub fn delete(__self: *@This(), key: []const u8) void { _ = __self.data.remove(key); } pub fn keys(__self: *@This()) [][]const u8 { _ = __self; return &[_][]const u8{}; } pub fn values(__self: *@This()) [][]const u8 { _ = __self; return &[_][]const u8{}; } pub fn items(__self: *@This()) []struct { key: []const u8, value: []const u8 } { _ = __self; return &.{}; } pub fn __len__(__self: *@This()) usize { return __self.data.count(); } pub fn __contains__(__self: *@This(), key: []const u8) bool { return __self.data.get(key) != null; } pub fn sync(__self: *@This()) void { _ = __self; } pub fn close(__self: *@This()) void { _ = __self; } pub fn __enter__(__self: *@This()) *@This() { return __self; } pub fn __exit__(__self: *@This(), _: anytype) void { __self.close(); } }{}") },
});
