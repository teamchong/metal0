/// Python numbers module - Numeric abstract base classes
const std = @import("std");
const h = @import("mod_helper.zig");

pub const Funcs = std.StaticStringMap(h.H).initComptime(.{
    .{ "Number", h.c("struct { _is_number: bool = true, pub fn register(_: @This(), _: std.mem.Allocator, _: anytype) !void {} }{}") },
    .{ "Complex", h.c("struct { real: f64 = 0.0, imag: f64 = 0.0, pub fn conjugate(__self: @This()) @This() { return .{ .real = __self.real, .imag = -__self.imag }; } pub fn __abs__(__self: @This()) f64 { return @sqrt(__self.real * __self.real + __self.imag * __self.imag); } pub fn __add__(__self: @This(), other: @This()) @This() { return .{ .real = __self.real + other.real, .imag = __self.imag + other.imag }; } pub fn __sub__(__self: @This(), other: @This()) @This() { return .{ .real = __self.real - other.real, .imag = __self.imag - other.imag }; } pub fn __mul__(__self: @This(), other: @This()) @This() { return .{ .real = __self.real * other.real - __self.imag * other.imag, .imag = __self.real * other.imag + __self.imag * other.real }; } pub fn __neg__(__self: @This()) @This() { return .{ .real = -__self.real, .imag = -__self.imag }; } pub fn __pos__(__self: @This()) @This() { return __self; } pub fn __eq__(__self: @This(), other: @This()) bool { return __self.real == other.real and __self.imag == other.imag; } pub fn __bool__(s: @This()) bool { return s.real != 0.0 or s.imag != 0.0; } pub fn register(_: @This(), _: std.mem.Allocator, _: anytype) !void {} }{}") },
    .{ "Real", h.c("struct { value: f64 = 0.0, pub fn __float__(__self: @This()) f64 { return __self.value; } pub fn __trunc__(__self: @This()) i64 { return @intFromFloat(@trunc(__self.value)); } pub fn __floor__(__self: @This()) i64 { return @intFromFloat(@floor(__self.value)); } pub fn __ceil__(__self: @This()) i64 { return @intFromFloat(@ceil(__self.value)); } pub fn __round__(__self: @This()) i64 { return @intFromFloat(@round(__self.value)); } pub fn __divmod__(__self: @This(), other: @This()) struct { f64, f64 } { return .{ @divFloor(__self.value, other.value), @mod(__self.value, other.value) }; } pub fn __floordiv__(__self: @This(), other: @This()) f64 { return @divFloor(__self.value, other.value); } pub fn __mod__(__self: @This(), other: @This()) f64 { return @mod(__self.value, other.value); } pub fn __lt__(__self: @This(), other: @This()) bool { return __self.value < other.value; } pub fn __le__(__self: @This(), other: @This()) bool { return __self.value <= other.value; } pub fn real(__self: @This()) f64 { return __self.value; } pub fn imag(__self: @This()) f64 { _ = __self; return 0.0; } pub fn conjugate(__self: @This()) @This() { return __self; } pub fn register(_: @This(), _: std.mem.Allocator, _: anytype) !void {} }{}") },
    .{ "Rational", h.c("struct { numerator: i64 = 0, denominator: i64 = 1, pub fn __float__(s: @This()) f64 { return @as(f64, @floatFromInt(s.numerator)) / @as(f64, @floatFromInt(s.denominator)); } pub fn register(_: @This(), _: std.mem.Allocator, _: anytype) !void {} }{}") },
    .{ "Integral", h.c("struct { value: i64 = 0, pub fn __int__(__self: @This()) i64 { return __self.value; } pub fn __index__(__self: @This()) i64 { return __self.value; } pub fn __and__(__self: @This(), other: @This()) @This() { return .{ .value = __self.value & other.value }; } pub fn __or__(__self: @This(), other: @This()) @This() { return .{ .value = __self.value | other.value }; } pub fn __xor__(__self: @This(), other: @This()) @This() { return .{ .value = __self.value ^ other.value }; } pub fn __invert__(__self: @This()) @This() { return .{ .value = ~__self.value }; } pub fn __lshift__(__self: @This(), n: i64) @This() { return .{ .value = __self.value << @intCast(n) }; } pub fn __rshift__(__self: @This(), n: i64) @This() { return .{ .value = __self.value >> @intCast(n) }; } pub fn numerator(__self: @This()) i64 { return __self.value; } pub fn denominator(__self: @This()) i64 { _ = __self; return 1; } pub fn register(_: @This(), _: std.mem.Allocator, _: anytype) !void {} }{}") },
});
