/// Python argparse module - Command-line argument parsing
const std = @import("std");
const h = @import("mod_helper.zig");

const ArgumentParserStruct = "struct { description: ?[]const u8 = null, prog: ?[]const u8 = null, arguments: std.ArrayList(Argument), parsed: hashmap_helper.StringHashMap([]const u8), positional_args: std.ArrayList([]const u8), const Argument = struct { name: []const u8, short: ?[]const u8 = null, help: ?[]const u8 = null, default: ?[]const u8 = null, required: bool = false, is_flag: bool = false, action: ?[]const u8 = null }; pub fn init() @This() { return @This(){ .arguments = .{}, .parsed = .{}, .positional_args = .{} }; } pub fn add_argument(__self: *@This(), name: []const u8) void { const is_optional = name.len > 0 and name[0] == '-'; __self.arguments.append(__global_allocator, Argument{ .name = name, .is_flag = is_optional }) catch {}; } pub fn parse_args(__self: *@This()) *@This() { const args_arr = std.process.argsAlloc(__global_allocator) catch return __self; var i: usize = 1; while (i < args_arr.len) : (i += 1) { const arg = args_arr[i]; if (arg.len > 2 and std.mem.startsWith(u8, arg, \"--\")) { if (std.mem.indexOfScalar(u8, arg, '=')) |eq| { __self.parsed.put(arg[2..eq], arg[eq + 1 ..]) catch {}; } else if (i + 1 < args_arr.len and !std.mem.startsWith(u8, args_arr[i + 1], \"-\")) { __self.parsed.put(arg[2..], args_arr[i + 1]) catch {}; i += 1; } else { __self.parsed.put(arg[2..], \"true\") catch {}; } } else if (arg.len > 1 and arg[0] == '-') { if (i + 1 < args_arr.len and !std.mem.startsWith(u8, args_arr[i + 1], \"-\")) { __self.parsed.put(arg[1..], args_arr[i + 1]) catch {}; i += 1; } else { __self.parsed.put(arg[1..], \"true\") catch {}; } } else { __self.positional_args.append(__global_allocator, arg) catch {}; } } return __self; } pub fn get(__self: *@This(), name: []const u8) ?[]const u8 { return __self.parsed.get(name); } pub fn get_positional(__self: *@This(), index: usize) ?[]const u8 { if (index < __self.positional_args.items.len) return __self.positional_args.items[index]; return null; } pub fn print_help(__self: *@This()) void { _ = __self; const stdout = std.io.getStdOut().writer(); stdout.print(\"usage: program [options]\\n\", .{}) catch {}; } }.init()";

const NamespaceStruct = "struct { data: hashmap_helper.StringHashMap([]const u8), pub fn init() @This() { return @This(){ .data = hashmap_helper.StringHashMap([]const u8).init(__global_allocator) }; } pub fn get(__self: *@This(), key: []const u8) ?[]const u8 { return __self.data.get(key); } pub fn set(__self: *@This(), key: []const u8, val: []const u8) void { __self.data.put(key, val) catch {}; } }.init()";

pub const Funcs = std.StaticStringMap(h.H).initComptime(.{
    .{ "ArgumentParser", h.c(ArgumentParserStruct) }, .{ "Namespace", h.c(NamespaceStruct) },
    .{ "FileType", h.c("\"r\"") }, .{ "REMAINDER", h.c("\"...\"") }, .{ "SUPPRESS", h.c("\"==SUPPRESS==\"") },
    .{ "OPTIONAL", h.c("\"?\"") }, .{ "ZERO_OR_MORE", h.c("\"*\"") }, .{ "ONE_OR_MORE", h.c("\"+\"") },
});
