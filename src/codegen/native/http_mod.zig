/// Python http module - HTTP protocol client/server
const std = @import("std");
const ast = @import("ast");
const h = @import("mod_helper.zig");
const CodegenError = @import("main.zig").CodegenError;
const NativeCodegen = @import("main.zig").NativeCodegen;

pub const HttpClientFuncs = std.StaticStringMap(h.H).initComptime(.{
    .{ "HTTPConnection", genHTTPConnection }, .{ "HTTPSConnection", genHTTPSConnection },
    .{ "HTTPResponse", h.c("struct { status: i64 = 200, reason: []const u8 = \"OK\", version: i64 = 11, headers: hashmap_helper.StringHashMap([]const u8) = .{}, pub fn read(__self: *@This(), amt: ?usize) []const u8 { _ = __self; _ = amt; return \"\"; } pub fn readline(__self: *@This(), limit: ?usize) []const u8 { _ = __self; _ = limit; return \"\"; } pub fn readlines(__self: *@This(), hint: ?usize) [][]const u8 { _ = __self; _ = hint; return &[_][]const u8{}; } pub fn getheader(__self: *@This(), name: []const u8, default: ?[]const u8) ?[]const u8 { return __self.headers.get(name) orelse default; } pub fn getheaders(__self: *@This()) []struct { []const u8, []const u8 } { _ = __self; return &.{}; } pub fn fileno(__self: *@This()) i64 { _ = __self; return -1; } pub fn close(__self: *@This()) void { _ = __self; } pub fn isclosed(__self: *@This()) bool { _ = __self; return false; } }{}") },
});
pub const HttpServerFuncs = std.StaticStringMap(h.H).initComptime(.{
    .{ "HTTPServer", h.c("struct { server_address: struct { []const u8, u16 } = .{ \"\", 8000 }, pub fn serve_forever(__self: *@This()) void { _ = __self; } pub fn handle_request(__self: *@This()) void { _ = __self; } pub fn shutdown(__self: *@This()) void { _ = __self; } pub fn server_close(__self: *@This()) void { _ = __self; } }{}") },
    .{ "ThreadingHTTPServer", h.c("struct { server_address: struct { []const u8, u16 } = .{ \"\", 8000 }, pub fn serve_forever(__self: *@This()) void { _ = __self; } pub fn shutdown(__self: *@This()) void { _ = __self; } }{}") },
    .{ "BaseHTTPRequestHandler", h.c("struct { command: []const u8 = \"\", path: []const u8 = \"\", request_version: []const u8 = \"HTTP/1.1\", headers: hashmap_helper.StringHashMap([]const u8) = .{}, rfile: ?*anyopaque = null, wfile: ?*anyopaque = null, pub fn send_response(__self: *@This(), code: i64, message: ?[]const u8) void { _ = __self; _ = code; _ = message; } pub fn send_header(__self: *@This(), keyword: []const u8, value: []const u8) void { _ = __self; _ = keyword; _ = value; } pub fn send_error(__self: *@This(), code: i64, message: ?[]const u8) void { _ = __self; _ = code; _ = message; } pub fn end_headers(__self: *@This()) void { _ = __self; } pub fn log_request(__self: *@This(), code: ?i64, size: ?i64) void { _ = __self; _ = code; _ = size; } pub fn log_error(__self: *@This(), format: []const u8) void { _ = __self; _ = format; } pub fn log_message(__self: *@This(), format: []const u8) void { _ = __self; _ = format; } }{}") },
    .{ "SimpleHTTPRequestHandler", h.c("struct { command: []const u8 = \"\", path: []const u8 = \"\", directory: []const u8 = \".\", extensions_map: hashmap_helper.StringHashMap([]const u8) = .{}, pub fn do_GET(__self: *@This()) void { _ = __self; } pub fn do_HEAD(__self: *@This()) void { _ = __self; } pub fn send_head(__self: *@This()) ?*anyopaque { _ = __self; return null; } pub fn list_directory(__self: *@This(), path: []const u8) ?*anyopaque { _ = __self; _ = path; return null; } pub fn translate_path(__self: *@This(), path: []const u8) []const u8 { _ = __self; return path; } pub fn guess_type(__self: *@This(), path: []const u8) []const u8 { _ = __self; _ = path; return \"application/octet-stream\"; } }{}") },
    .{ "CGIHTTPRequestHandler", h.c("struct { cgi_directories: [][]const u8 = &[_][]const u8{ \"/cgi-bin\", \"/htbin\" }, pub fn do_POST(__self: *@This()) void { _ = __self; } pub fn is_cgi(__self: *@This()) bool { _ = __self; return false; } }{}") },
});
pub const HttpCookiesFuncs = std.StaticStringMap(h.H).initComptime(.{
    .{ "SimpleCookie", h.c("struct { cookies: hashmap_helper.StringHashMap(Morsel) = .{}, pub const Morsel = struct { key: []const u8 = \"\", value: []const u8 = \"\", coded_value: []const u8 = \"\", path: []const u8 = \"/\", domain: []const u8 = \"\", expires: []const u8 = \"\", max_age: ?i64 = null, secure: bool = false, httponly: bool = false, samesite: []const u8 = \"\", pub fn output(__self: *@This(), header: []const u8) []const u8 { _ = __self; _ = header; return \"\"; } pub fn js_output(__self: *@This()) []const u8 { _ = __self; return \"\"; } pub fn OutputString(__self: *@This()) []const u8 { _ = __self; return \"\"; } }; pub fn load(__self: *@This(), rawdata: anytype) void { _ = __self; _ = rawdata; } pub fn output(__self: *@This(), header: []const u8, sep: []const u8) []const u8 { _ = __self; _ = header; _ = sep; return \"\"; } pub fn js_output(__self: *@This()) []const u8 { _ = __self; return \"\"; } }{}") },
    .{ "BaseCookie", h.c("struct { cookies: hashmap_helper.StringHashMap(anyopaque) = .{} }{}") },
});

fn genHTTPConnection(self: *NativeCodegen, args: []ast.Node) CodegenError!void {
    try self.emit("struct { host: []const u8 = ");
    if (args.len > 0) try self.genExpr(args[0]) else try self.emit("\"localhost\"");
    try self.emit(", port: u16 = ");
    if (args.len > 1) try self.genExpr(args[1]) else try self.emit("80");
    try self.emit(", socket: ?i64 = null, response_buf: []u8 = &[_]u8{}, pub fn request(__self: *@This(), method: []const u8, url: []const u8, body: ?[]const u8, headers: anytype) void { _ = __self; _ = method; _ = url; _ = body; _ = headers; } pub fn getresponse(__self: *@This()) HTTPResponse { _ = __self; return HTTPResponse{}; } pub fn set_debuglevel(__self: *@This(), level: i64) void { _ = __self; _ = level; } pub fn set_tunnel(__self: *@This(), host: []const u8, port: ?u16, headers: anytype) void { _ = __self; _ = host; _ = port; _ = headers; } pub fn connect(__self: *@This()) void { _ = __self; } pub fn close(__self: *@This()) void { __self.socket = null; } pub fn putrequest(__self: *@This(), method: []const u8, url: []const u8) void { _ = __self; _ = method; _ = url; } pub fn putheader(__self: *@This(), header: []const u8, value: []const u8) void { _ = __self; _ = header; _ = value; } pub fn endheaders(__self: *@This(), message_body: ?[]const u8) void { _ = __self; _ = message_body; } pub fn send(__self: *@This(), data: []const u8) void { _ = __self; _ = data; } }{}");
}
fn genHTTPSConnection(self: *NativeCodegen, args: []ast.Node) CodegenError!void {
    try self.emit("struct { host: []const u8 = ");
    if (args.len > 0) try self.genExpr(args[0]) else try self.emit("\"localhost\"");
    try self.emit(", port: u16 = ");
    if (args.len > 1) try self.genExpr(args[1]) else try self.emit("443");
    try self.emit(", socket: ?i64 = null, pub fn request(__self: *@This(), method: []const u8, url: []const u8, body: ?[]const u8, headers: anytype) void { _ = __self; _ = method; _ = url; _ = body; _ = headers; } pub fn getresponse(__self: *@This()) HTTPResponse { _ = __self; return HTTPResponse{}; } pub fn connect(__self: *@This()) void { _ = __self; } pub fn close(__self: *@This()) void { __self.socket = null; } }{}");
}

pub fn genHTTPStatus(self: *NativeCodegen, args: []ast.Node) CodegenError!void {
    _ = args;
    try self.emit("struct { pub const CONTINUE = 100; pub const SWITCHING_PROTOCOLS = 101; pub const PROCESSING = 102; pub const OK = 200; pub const CREATED = 201; pub const ACCEPTED = 202; pub const NON_AUTHORITATIVE_INFORMATION = 203; pub const NO_CONTENT = 204; pub const RESET_CONTENT = 205; pub const PARTIAL_CONTENT = 206; pub const MULTI_STATUS = 207; pub const ALREADY_REPORTED = 208; pub const MULTIPLE_CHOICES = 300; pub const MOVED_PERMANENTLY = 301; pub const FOUND = 302; pub const SEE_OTHER = 303; pub const NOT_MODIFIED = 304; pub const USE_PROXY = 305; pub const TEMPORARY_REDIRECT = 307; pub const PERMANENT_REDIRECT = 308; pub const BAD_REQUEST = 400; pub const UNAUTHORIZED = 401; pub const PAYMENT_REQUIRED = 402; pub const FORBIDDEN = 403; pub const NOT_FOUND = 404; pub const METHOD_NOT_ALLOWED = 405; pub const NOT_ACCEPTABLE = 406; pub const PROXY_AUTHENTICATION_REQUIRED = 407; pub const REQUEST_TIMEOUT = 408; pub const CONFLICT = 409; pub const GONE = 410; pub const LENGTH_REQUIRED = 411; pub const PRECONDITION_FAILED = 412; pub const REQUEST_ENTITY_TOO_LARGE = 413; pub const REQUEST_URI_TOO_LONG = 414; pub const UNSUPPORTED_MEDIA_TYPE = 415; pub const REQUESTED_RANGE_NOT_SATISFIABLE = 416; pub const EXPECTATION_FAILED = 417; pub const IM_A_TEAPOT = 418; pub const MISDIRECTED_REQUEST = 421; pub const UNPROCESSABLE_ENTITY = 422; pub const LOCKED = 423; pub const FAILED_DEPENDENCY = 424; pub const TOO_EARLY = 425; pub const UPGRADE_REQUIRED = 426; pub const PRECONDITION_REQUIRED = 428; pub const TOO_MANY_REQUESTS = 429; pub const REQUEST_HEADER_FIELDS_TOO_LARGE = 431; pub const UNAVAILABLE_FOR_LEGAL_REASONS = 451; pub const INTERNAL_SERVER_ERROR = 500; pub const NOT_IMPLEMENTED = 501; pub const BAD_GATEWAY = 502; pub const SERVICE_UNAVAILABLE = 503; pub const GATEWAY_TIMEOUT = 504; pub const HTTP_VERSION_NOT_SUPPORTED = 505; pub const VARIANT_ALSO_NEGOTIATES = 506; pub const INSUFFICIENT_STORAGE = 507; pub const LOOP_DETECTED = 508; pub const NOT_EXTENDED = 510; pub const NETWORK_AUTHENTICATION_REQUIRED = 511; }");
}
pub fn genHTTPResponseType(self: *NativeCodegen, args: []ast.Node) CodegenError!void {
    _ = args;
    try self.emit("const HTTPResponse = struct { status: i64 = 200, reason: []const u8 = \"OK\", pub fn read(__self: *@This()) []const u8 { _ = __self; return \"\"; } pub fn getheader(__self: *@This(), name: []const u8) ?[]const u8 { _ = __self; _ = name; return null; } };");
}
