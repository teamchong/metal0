/// Python threading module - Thread-based parallelism
const std = @import("std");
const ast = @import("ast");
const CodegenError = @import("main.zig").CodegenError;
const NativeCodegen = @import("main.zig").NativeCodegen;

const ModuleHandler = *const fn (*NativeCodegen, []ast.Node) CodegenError!void;
fn genConst(comptime v: []const u8) ModuleHandler {
    return struct { fn f(self: *NativeCodegen, args: []ast.Node) CodegenError!void { _ = args; try self.emit(v); } }.f;
}

pub const Funcs = std.StaticStringMap(ModuleHandler).initComptime(.{
    .{ "Thread", genConst("struct { handle: ?std.Thread = null, name: ?[]const u8 = null, daemon: bool = false, pub fn start(s: *@This()) void { _ = s; } pub fn join(s: *@This()) void { if (s.handle) |h| h.join(); } pub fn is_alive(s: *@This()) bool { _ = s; return false; } pub fn getName(s: *@This()) ?[]const u8 { return s.name; } pub fn setName(s: *@This(), n: []const u8) void { s.name = n; } pub fn isDaemon(s: *@This()) bool { return s.daemon; } pub fn setDaemon(s: *@This(), d: bool) void { s.daemon = d; } }{}") },
    .{ "Lock", genConst("struct { mutex: std.Thread.Mutex = .{}, pub fn acquire(s: *@This()) void { s.mutex.lock(); } pub fn release(s: *@This()) void { s.mutex.unlock(); } pub fn locked(s: *@This()) bool { _ = s; return false; } pub fn __enter__(s: *@This()) *@This() { s.acquire(); return s; } pub fn __exit__(s: *@This(), _: anytype) void { s.release(); } }{}") },
    .{ "RLock", genConst("struct { mutex: std.Thread.Mutex = .{}, pub fn acquire(s: *@This()) void { s.mutex.lock(); } pub fn release(s: *@This()) void { s.mutex.unlock(); } pub fn locked(s: *@This()) bool { _ = s; return false; } pub fn __enter__(s: *@This()) *@This() { s.acquire(); return s; } pub fn __exit__(s: *@This(), _: anytype) void { s.release(); } }{}") },
    .{ "Condition", genConst("struct { cond: std.Thread.Condition = .{}, mutex: std.Thread.Mutex = .{}, pub fn acquire(s: *@This()) void { s.mutex.lock(); } pub fn release(s: *@This()) void { s.mutex.unlock(); } pub fn wait(s: *@This()) void { s.cond.wait(&s.mutex); } pub fn notify(s: *@This()) void { s.cond.signal(); } pub fn notify_all(s: *@This()) void { s.cond.broadcast(); } pub fn __enter__(s: *@This()) *@This() { s.acquire(); return s; } pub fn __exit__(s: *@This(), _: anytype) void { s.release(); } }{}") },
    .{ "Semaphore", genConst("struct { count: i64 = 1, mutex: std.Thread.Mutex = .{}, pub fn acquire(s: *@This()) void { s.mutex.lock(); s.count -= 1; s.mutex.unlock(); } pub fn release(s: *@This()) void { s.mutex.lock(); s.count += 1; s.mutex.unlock(); } pub fn __enter__(s: *@This()) *@This() { s.acquire(); return s; } pub fn __exit__(s: *@This(), _: anytype) void { s.release(); } }{}") },
    .{ "BoundedSemaphore", genConst("struct { count: i64 = 1, mutex: std.Thread.Mutex = .{}, pub fn acquire(s: *@This()) void { s.mutex.lock(); s.count -= 1; s.mutex.unlock(); } pub fn release(s: *@This()) void { s.mutex.lock(); s.count += 1; s.mutex.unlock(); } pub fn __enter__(s: *@This()) *@This() { s.acquire(); return s; } pub fn __exit__(s: *@This(), _: anytype) void { s.release(); } }{}") },
    .{ "Event", genConst("struct { flag: bool = false, mutex: std.Thread.Mutex = .{}, cond: std.Thread.Condition = .{}, pub fn set(s: *@This()) void { s.mutex.lock(); s.flag = true; s.cond.broadcast(); s.mutex.unlock(); } pub fn clear(s: *@This()) void { s.mutex.lock(); s.flag = false; s.mutex.unlock(); } pub fn is_set(s: *@This()) bool { s.mutex.lock(); defer s.mutex.unlock(); return s.flag; } pub fn wait(s: *@This()) void { s.mutex.lock(); while (!s.flag) s.cond.wait(&s.mutex); s.mutex.unlock(); } }{}") },
    .{ "Barrier", genConst("struct { parties: i64 = 1, count: i64 = 0, pub fn wait(s: *@This()) i64 { s.count += 1; return s.count - 1; } pub fn reset(s: *@This()) void { s.count = 0; } pub fn abort(s: *@This()) void { _ = s; } }{}") },
    .{ "Timer", genConst("struct { interval: f64 = 0, pub fn start(s: *@This()) void { _ = s; } pub fn cancel(s: *@This()) void { _ = s; } }{}") },
    .{ "current_thread", genConst("struct { handle: ?std.Thread = null, name: ?[]const u8 = null, daemon: bool = false, pub fn start(s: *@This()) void { _ = s; } pub fn join(s: *@This()) void { if (s.handle) |h| h.join(); } pub fn is_alive(s: *@This()) bool { _ = s; return false; } pub fn getName(s: *@This()) ?[]const u8 { return s.name; } pub fn setName(s: *@This(), n: []const u8) void { s.name = n; } pub fn isDaemon(s: *@This()) bool { return s.daemon; } pub fn setDaemon(s: *@This(), d: bool) void { s.daemon = d; } }{}") },
    .{ "main_thread", genConst("struct { handle: ?std.Thread = null, name: ?[]const u8 = null, daemon: bool = false, pub fn start(s: *@This()) void { _ = s; } pub fn join(s: *@This()) void { if (s.handle) |h| h.join(); } pub fn is_alive(s: *@This()) bool { _ = s; return false; } pub fn getName(s: *@This()) ?[]const u8 { return s.name; } pub fn setName(s: *@This(), n: []const u8) void { s.name = n; } pub fn isDaemon(s: *@This()) bool { return s.daemon; } pub fn setDaemon(s: *@This(), d: bool) void { s.daemon = d; } }{}") },
    .{ "active_count", genConst("@as(i64, 1)") }, .{ "enumerate", genConst("&[_]@TypeOf(struct{}{}){}") },
    .{ "local", genConst("struct { data: hashmap_helper.StringHashMap([]const u8) = hashmap_helper.StringHashMap([]const u8).init(__global_allocator) }{}") },
});
